/**
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package org.eclipse.emf.parsley.dsl.scoping;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.beans.Introspector;
import java.util.Arrays;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.parsley.dsl.model.EmfFeatureAccess;
import org.eclipse.emf.parsley.dsl.scoping.AbstractEmfParsleyDslScopeProvider;
import org.eclipse.emf.parsley.dsl.util.EmfParsleyDslModelUtil;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.SimpleScope;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class EmfParsleyDslScopeProvider extends AbstractEmfParsleyDslScopeProvider {
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope _xblockexpression = null;
    {
      final IScope scope = this.createCustomScope(context, reference);
      if ((scope != null)) {
        return scope;
      }
      _xblockexpression = super.getScope(context, reference);
    }
    return _xblockexpression;
  }
  
  public IScope createCustomScope(final EObject context, final EReference reference) {
    EClassifier _eType = reference.getEType();
    EClass _jvmMember = TypesPackage.eINSTANCE.getJvmMember();
    boolean _equals = Objects.equal(_eType, _jvmMember);
    if (_equals) {
      EmfFeatureAccess _containingEmfFeatureAccess = EmfParsleyDslModelUtil.containingEmfFeatureAccess(context);
      JvmTypeReference _parameterType = null;
      if (_containingEmfFeatureAccess!=null) {
        _parameterType=_containingEmfFeatureAccess.getParameterType();
      }
      JvmType _type = null;
      if (_parameterType!=null) {
        _type=_parameterType.getType();
      }
      IScope _customScope = null;
      if (_type!=null) {
        _customScope=this.customScope(_type);
      }
      return _customScope;
    }
    return null;
  }
  
  protected IScope _customScope(final JvmType t) {
    return null;
  }
  
  protected IScope _customScope(final JvmGenericType t) {
    final Function1<JvmOperation, Boolean> _function = new Function1<JvmOperation, Boolean>() {
      @Override
      public Boolean apply(final JvmOperation it) {
        boolean _isStatic = it.isStatic();
        return Boolean.valueOf((!_isStatic));
      }
    };
    final Function<JvmOperation, QualifiedName> _function_1 = new Function<JvmOperation, QualifiedName>() {
      @Override
      public QualifiedName apply(final JvmOperation it) {
        QualifiedName _xifexpression = null;
        boolean _isGetterMethod = EmfParsleyDslScopeProvider.this.isGetterMethod(it.getSimpleName());
        if (_isGetterMethod) {
          _xifexpression = QualifiedName.create(EmfParsleyDslScopeProvider.this.getPropertyNameForGetterMethod(it.getSimpleName()));
        } else {
          _xifexpression = null;
        }
        return _xifexpression;
      }
    };
    Iterable<IEObjectDescription> _scopedElementsFor = Scopes.<JvmOperation>scopedElementsFor(IterableExtensions.<JvmOperation>filter(Iterables.<JvmOperation>filter(t.getAllFeatures(), JvmOperation.class), _function), _function_1);
    return new SimpleScope(_scopedElementsFor);
  }
  
  public boolean isGetterMethod(final String opName) {
    return (this.getterMethodForNonBoolean(opName) || this.getterMethodForBoolean(opName));
  }
  
  public String getPropertyNameForGetterMethod(final String opName) {
    boolean _terMethodForNonBoolean = this.getterMethodForNonBoolean(opName);
    if (_terMethodForNonBoolean) {
      return Introspector.decapitalize(opName.substring(3));
    }
    boolean _terMethodForBoolean = this.getterMethodForBoolean(opName);
    if (_terMethodForBoolean) {
      return Introspector.decapitalize(opName.substring(2));
    }
    return null;
  }
  
  private boolean getterMethodForBoolean(final String opName) {
    return this.getterMethodInternal(opName, "is");
  }
  
  private boolean getterMethodForNonBoolean(final String opName) {
    return this.getterMethodInternal(opName, "get");
  }
  
  private boolean getterMethodInternal(final String opName, final String prefix) {
    return ((opName.startsWith(prefix) && (opName.length() > prefix.length())) && 
      Character.isUpperCase(opName.charAt(prefix.length())));
  }
  
  public IScope customScope(final JvmType t) {
    if (t instanceof JvmGenericType) {
      return _customScope((JvmGenericType)t);
    } else if (t != null) {
      return _customScope(t);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(t).toString());
    }
  }
}
