/*
* generated by Xtext
*/
grammar InternalDotEscString;

options {
	superClass=AbstractInternalAntlrParser;
	
}

@lexer::header {
package org.eclipse.gef.dot.internal.language.parser.antlr.internal;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}

@parser::header {
package org.eclipse.gef.dot.internal.language.parser.antlr.internal; 

import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.common.util.Enumerator;
import org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser;
import org.eclipse.xtext.parser.antlr.XtextTokenStream;
import org.eclipse.xtext.parser.antlr.XtextTokenStream.HiddenTokens;
import org.eclipse.xtext.parser.antlr.AntlrDatatypeRuleToken;
import org.eclipse.gef.dot.internal.language.services.DotEscStringGrammarAccess;

}

@parser::members {

 	private DotEscStringGrammarAccess grammarAccess;
 	
    public InternalDotEscStringParser(TokenStream input, DotEscStringGrammarAccess grammarAccess) {
        this(input);
        this.grammarAccess = grammarAccess;
        registerRules(grammarAccess.getGrammar());
    }
    
    @Override
    protected String getFirstRuleName() {
    	return "EscString";	
   	}
   	
   	@Override
   	protected DotEscStringGrammarAccess getGrammarAccess() {
   		return grammarAccess;
   	}
}

@rulecatch { 
    catch (RecognitionException re) { 
        recover(input,re); 
        appendSkippedTokens();
    } 
}




// Entry rule entryRuleEscString
entryRuleEscString returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getEscStringRule()); }
	 iv_ruleEscString=ruleEscString 
	 { $current=$iv_ruleEscString.current; } 
	 EOF 
;

// Rule EscString
ruleEscString returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
((
    {
        $current = forceCreateModelElement(
            grammarAccess.getEscStringAccess().getEscStringAction_0(),
            $current);
    }
)(
(
		{ 
	        newCompositeNode(grammarAccess.getEscStringAccess().getLinesJustifiedTextParserRuleCall_1_0()); 
	    }
		lv_lines_1_0=ruleJustifiedText		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getEscStringRule());
	        }
       		add(
       			$current, 
       			"lines",
        		lv_lines_1_0, 
        		"JustifiedText");
	        afterParserOrEnumRuleCall();
	    }

)
)*)
;





// Entry rule entryRuleJustifiedText
entryRuleJustifiedText returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getJustifiedTextRule()); }
	 iv_ruleJustifiedText=ruleJustifiedText 
	 { $current=$iv_ruleJustifiedText.current; } 
	 EOF 
;

// Rule JustifiedText
ruleJustifiedText returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
(((
(
		{ 
	        newCompositeNode(grammarAccess.getJustifiedTextAccess().getTextTEXTParserRuleCall_0_0_0()); 
	    }
		lv_text_0_0=ruleTEXT		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getJustifiedTextRule());
	        }
       		set(
       			$current, 
       			"text",
        		lv_text_0_0, 
        		"TEXT");
	        afterParserOrEnumRuleCall();
	    }

)
)((
(
ruleJustification
)
)=>
(
		{ 
	        newCompositeNode(grammarAccess.getJustifiedTextAccess().getJustificationJustificationEnumRuleCall_0_1_0()); 
	    }
		lv_justification_1_0=ruleJustification		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getJustifiedTextRule());
	        }
       		set(
       			$current, 
       			"justification",
        		lv_justification_1_0, 
        		"Justification");
	        afterParserOrEnumRuleCall();
	    }

)
)?)
    |(
(
		{ 
	        newCompositeNode(grammarAccess.getJustifiedTextAccess().getJustificationJustificationEnumRuleCall_1_0()); 
	    }
		lv_justification_2_0=ruleJustification		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getJustifiedTextRule());
	        }
       		set(
       			$current, 
       			"justification",
        		lv_justification_2_0, 
        		"Justification");
	        afterParserOrEnumRuleCall();
	    }

)
))
;





// Entry rule entryRuleTEXT
entryRuleTEXT returns [String current=null] 
	:
	{ newCompositeNode(grammarAccess.getTEXTRule()); } 
	 iv_ruleTEXT=ruleTEXT 
	 { $current=$iv_ruleTEXT.current.getText(); }  
	 EOF 
;

// Rule TEXT
ruleTEXT returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
(    this_CHAR_0=RULE_CHAR    {
		$current.merge(this_CHAR_0);
    }

    { 
    newLeafNode(this_CHAR_0, grammarAccess.getTEXTAccess().getCHARTerminalRuleCall_0()); 
    }
(( RULE_CHAR)=>    this_CHAR_1=RULE_CHAR    {
		$current.merge(this_CHAR_1);
    }

    { 
    newLeafNode(this_CHAR_1, grammarAccess.getTEXTAccess().getCHARTerminalRuleCall_1()); 
    }
)*)
    ;





// Rule Justification
ruleJustification returns [Enumerator current=null] 
    @init { enterRule(); }
    @after { leaveRule(); }:
((	enumLiteral_0='\\n' 
	{
        $current = grammarAccess.getJustificationAccess().getCENTEREDEnumLiteralDeclaration_0().getEnumLiteral().getInstance();
        newLeafNode(enumLiteral_0, grammarAccess.getJustificationAccess().getCENTEREDEnumLiteralDeclaration_0()); 
    }
)
    |(	enumLiteral_1='\\l' 
	{
        $current = grammarAccess.getJustificationAccess().getLEFTEnumLiteralDeclaration_1().getEnumLiteral().getInstance();
        newLeafNode(enumLiteral_1, grammarAccess.getJustificationAccess().getLEFTEnumLiteralDeclaration_1()); 
    }
)
    |(	enumLiteral_2='\\r' 
	{
        $current = grammarAccess.getJustificationAccess().getRIGHTEnumLiteralDeclaration_2().getEnumLiteral().getInstance();
        newLeafNode(enumLiteral_2, grammarAccess.getJustificationAccess().getRIGHTEnumLiteralDeclaration_2()); 
    }
));



RULE_CHAR : .;


